
-- VHDL Testbench Template 
-- Autogenerated from nicruireq::hdltools app 
-- Written by Nicolas Ruiz Requejo
-- 
-- Notice:
-- Fill this template with your test code
-- Please if you discover a bug submit an Issue in
-- https://github.com/nicruireq/XilinxTclStore
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.all;

library periscore32;
use periscore32.cpu_types.all;
use periscore32.testbench_helpers.all;

ENTITY direct_mapped_DCache_tb IS
END direct_mapped_DCache_tb;

ARCHITECTURE behavior OF direct_mapped_DCache_tb IS 

	-- Component Declaration for the Unit Under Test (UUT)
    component direct_mapped_DCache is
        generic(
            address_bits : integer := 32; --! width in bits of input address
            index_width : integer := 8; --! number of lines of cache index
            block_size : integer := 32; --! size of cache block
            byte_select : integer := 2 --! number of bits to select byte in each block
        );
        port (
            clk : in std_logic;
            write_enable : in std_logic;
            read_enable : in std_logic;
            address : in word;
            select_type : in operand_type;   --! Allows load/store of byte, halfword and word
            signed_unsigned : in std_logic; --! Allows to select for signed or unsigned byte/half
            data_in : in word;
            data_out : out word
        );
    end component ;

	-- Inputs and Outputs
	signal clk : std_logic;
	signal write_enable : std_logic;
    signal read_enable : in std_logic;
	signal address : word;
    signal select_type : operand_type;
    signal signed_unsigned : std_logic;
	signal data_in : word;
	signal data_out : word;

    constant clock_period: time := 10 ns;
    signal stop_the_clock: boolean;

BEGIN

	-- Instantiate the Unit Under Test (UUT)
	-- UUT:
	my_direct_mapped_dcache : direct_mapped_DCache
	port map(
		clk => clk ,
		write_enable => write_enable ,
		read_enable => read_enable ,
		address => address ,
        select_type => select_type,
        signed_unsigned => signed_unsigned,
		data_in => data_in ,
		data_out => data_out );

    clocking: process
    begin
        while not stop_the_clock loop
            clk <= '0', '1' after clock_period / 2;
            wait for clock_period;
        end loop;
        wait;
    end process;

   -- Stimulus process
   stim_proc: process
        variable addr_mod4 : 
            unsigned(address'length-1 downto 0) := x"00000000";
   begin

        -- Put initialisation code here
        wait for 20 ns;
	    -- Put test bench stimulus code here
        -- Writing
        write_enable <= '1';
        data_in <= rand_slv(data_in'length);
        address <= std_logic_vector(addr_mod4);
        wait for 10 ns;
        gen_address : while addr_mod4 < x"000000ff" loop
            --address <= std_logic_vector(to_unsigned(i, address'length));
            addr_mod4 := addr_mod4 + x"00000004";
            address <= std_logic_vector(addr_mod4);
            data_in <= rand_slv(data_in'length);
            wait for 10 ns;
        end loop ; -- gen_address
        
        -- write 

        -- reading
        

        wait;
   end process;

END;
