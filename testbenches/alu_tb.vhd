
-- VHDL Testbench Template 
-- Autogenerated from nicruireq::hdltools app 
-- Written by Nicolas Ruiz Requejo
-- 
-- Notice:
-- Fill this template with your test code
-- Please if you discover a bug submit an Issue in
-- https://github.com/nicruireq/XilinxTclStore
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

library periscore32;
use periscore32.cpu_types.all;

ENTITY alu_tb IS
END alu_tb;

ARCHITECTURE behavior OF alu_tb IS 

	-- Component Declaration for the Unit Under Test (UUT)
component alu is
    generic (
        data_width : integer := 32;
        alu_control_width : integer := 5
    );
    port (
        operand_A : in std_logic_vector(data_width-1 downto 0);
        operand_B : in std_logic_vector(data_width-1 downto 0);
        control : in std_logic_vector(alu_control_width-1 downto 0);
        computation_out : out std_logic_vector(data_width-1 downto 0);
        zero_flag : out std_logic;
        overflow_flag : out std_logic
    ) ;
end component;
    
    constant data_width : integer := 32;
    constant alu_control_width : integer := 5;
	-- Inputs and Outputs
	signal operand_A : std_logic_vector(data_width-1 downto 0);
	signal operand_B : std_logic_vector(data_width-1 downto 0);
	signal control : std_logic_vector(alu_control_width-1 downto 0);
	signal computation_out : std_logic_vector(data_width-1 downto 0);
	signal zero_flag : std_logic;
	signal overflow_flag : std_logic;


BEGIN

	-- Instantiate the Unit Under Test (UUT)
	-- UUT:
	my_alu : alu
	generic map(
		data_width => 32,
		alu_control_width => 5)
	port map(
		operand_A => operand_A ,
		operand_B => operand_B ,
		control => control ,
		computation_out => computation_out ,
		zero_flag => zero_flag ,
		overflow_flag => overflow_flag );


   -- Stimulus process
   stim_proc: process
   begin
	-- Put test bench stimulus code here
		operand_A <= x"00001388";	-- 5000
		operand_B <= x"0008ff56";	-- 589654

		control <= alu_add;
		assert computation_out = x"000912de" report "alu_add: bad result";
		wait for 100 ns;

		control <= alu_add_unsigned;
		assert computation_out = x"000912de" report "alu_add_unsigned: bad result";
		wait for 100 ns;

		control <= alu_sub;
		assert computation_out = x"fff71432" report "alu_sub: bad result";
		wait for 100 ns;

		control <= alu_sub_unsigned;
		assert computation_out = x"fff71432" report "alu_sub_unsigned: bad result";
		wait for 100 ns;

		control <= alu_set_on_less;
		assert computation_out = x"00000001" report "alu_set_on_less: bad result";
		wait for 100 ns;

		control <= alu_set_on_less_unsigned;
		assert computation_out = x"00000001" report "alu_set_on_less_unsigned: bad result";
		wait for 100 ns;

		control <= alu_and;
		assert computation_out = x"00001300" report "alu_and: bad result";
		wait for 100 ns;

		control <= alu_xor;
		assert computation_out = x"0008ecde" report "alu_xor: bad result";
		wait for 100 ns;

		control <= alu_nor;
		assert computation_out = x"fff70021" report "alu_nor: bad result";
		wait for 100 ns;
		
		control <= alu_or;
		assert computation_out = x"0008ffde" report "alu_or: bad result";
		wait for 100 ns;

		-- shifts with positive operand
		operand_B <= x"00000008";	-- 8
		control <= alu_sll;
		assert computation_out = x"00138800" report "alu_sll: bad result";
		wait for 100 ns;

		control <= alu_slr;
		assert computation_out = x"00000013" report "alu_slr: bad result";
		wait for 100 ns;

		control <= alu_sra;
		assert computation_out = x"00000013" report "alu_sra: bad result";
		wait for 100 ns;

		-- shift right arithmetic with negative operand
		operand_A <= x"ff695b4c";	-- -9872564
		control <= alu_sra
		assert computation_out = x"ffff695b" report "alu_sra: bad result";
		wait for 100 ns;

		-- one negative and one positive
		operand_B <= x"0008ff56";
		control <= alu_add;
		assert computation_out = x"ff725aa2" report "alu_add: bad result";
		wait for 100 ns;

		control <= alu_add_unsigned;
		assert computation_out = x"ff725aa2" report "alu_add_unsigned: bad result";
		wait for 100 ns;

		control <= alu_sub;
		assert computation_out = x"ff605bf6" report "alu_sub: bad result";
		wait for 100 ns;

		control <= alu_sub_unsigned;
		assert computation_out = x"ff605bf6" report "alu_sub_unsigned: bad result";
		wait for 100 ns;

		control <= alu_set_on_less;
		assert computation_out = x"00000001" report "alu_set_on_less: bad result";
		wait for 100 ns;

		control <= alu_set_on_less_unsigned;
		assert computation_out = x"00000000" report "alu_set_on_less_unsigned: bad result";
		wait for 100 ns;

		-- overflows testing
		--operand_A <= x"80000000";
		--operand_B <= x"";
		
		
      wait;
   end process;

END;

